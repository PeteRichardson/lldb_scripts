#!/Library/Developer/CommandLineTools/usr/bin/python3
# NOTE:  must use the python3 in the CommandLineTools directory, not the Homebrew python3
#        because the Homebrew python3 does not have the lldb module

import os

import sys
import argparse

try:
    # make lldb module available
    sys.path.append('/Library/Developer/CommandLineTools/Library/PrivateFrameworks/LLDB.framework/Versions/A/Resources/Python')
    import lldb
except ImportError:
        print("Failed to import lldb module.  Make sure the path to the lldb module is correct.", file=sys.stderr)
        sys.exit(1)


def validate_binary(path):
    if os.path.exists(path) == False:
        raise argparse.ArgumentTypeError(f"'{path}' does not exist.")
    if not os.path.isfile(path):
        raise argparse.ArgumentTypeError(f"'{path}' is not a file.")
    return path

def get_parser():
    parser = argparse.ArgumentParser(description='List sections in a binary file (executable, shared library, object file, etc.) using lldb')
    parser.add_argument('binary', help='path to the binary to examine.',  type=validate_binary)
    #parser.add_argument('-c', '--csv', action='store_true', help='output in csv format')
    parser.add_argument('-d', '--dependencies', action='store_true', help='also examine dependent binaries')
    parser.add_argument('-k', '--skip-subsections', action='store_true', help='do not list subsections')
    return parser

section_types = {
	lldb.eSectionTypeInvalid: "Invalid",
	lldb.eSectionTypeCode: "Code",
	lldb.eSectionTypeContainer: "Container",
	lldb.eSectionTypeData: "Data",
	lldb.eSectionTypeDataCString: "DataCString",
	lldb.eSectionTypeDataCStringPointers: "DataCStringPointers",
	lldb.eSectionTypeDataSymbolAddress: "DataSymbolAddress",
	lldb.eSectionTypeData4: "Data4",
	lldb.eSectionTypeData8: "Data8",
	lldb.eSectionTypeData16: "Data16",
	lldb.eSectionTypeDataPointers: "DataPointers",
	lldb.eSectionTypeDebug: "Debug",
	lldb.eSectionTypeZeroFill: "ZeroFill",
	lldb.eSectionTypeDataObjCMessageRefs: "DataObjCMessageRefs",
	lldb.eSectionTypeDataObjCCFStrings: "DataObjCCFStrings",
	lldb.eSectionTypeDWARFDebugAbbrev: "DWARFDebugAbbrev",
	lldb.eSectionTypeDWARFDebugAddr: "DWARFDebugAddr",
	lldb.eSectionTypeDWARFDebugAranges: "DWARFDebugAranges",
	lldb.eSectionTypeDWARFDebugCuIndex: "DWARFDebugCuIndex",
	lldb.eSectionTypeDWARFDebugFrame: "DWARFDebugFrame",
	lldb.eSectionTypeDWARFDebugInfo: "DWARFDebugInfo",
	lldb.eSectionTypeDWARFDebugLine: "DWARFDebugLine",
	lldb.eSectionTypeDWARFDebugLoc: "DWARFDebugLoc",
	lldb.eSectionTypeDWARFDebugMacInfo: "DWARFDebugMacInfo",
	lldb.eSectionTypeDWARFDebugMacro: "DWARFDebugMacro",
	lldb.eSectionTypeDWARFDebugPubNames: "DWARFDebugPubNames",
	lldb.eSectionTypeDWARFDebugPubTypes: "DWARFDebugPubTypes",
	lldb.eSectionTypeDWARFDebugRanges: "DWARFDebugRanges",
	lldb.eSectionTypeDWARFDebugStr: "DWARFDebugStr",
	lldb.eSectionTypeDWARFDebugStrOffsets: "DWARFDebugStrOffsets",
	lldb.eSectionTypeDWARFAppleNames: "DWARFAppleNames",
	lldb.eSectionTypeDWARFAppleTypes: "DWARFAppleTypes",
	lldb.eSectionTypeDWARFAppleNamespaces: "DWARFAppleNamespaces",
	lldb.eSectionTypeDWARFAppleObjC: "DWARFAppleObjC",
	lldb.eSectionTypeELFSymbolTable: "ELFSymbolTable",
	lldb.eSectionTypeELFDynamicSymbols: "ELFDynamicSymbols",
	lldb.eSectionTypeELFRelocationEntries: "ELFRelocationEntries",
	lldb.eSectionTypeELFDynamicLinkInfo: "ELFDynamicLinkInfo",
	lldb.eSectionTypeEHFrame: "EHFrame",
	lldb.eSectionTypeARMexidx: "ARMexidx",
	lldb.eSectionTypeARMextab: "ARMextab",
	lldb.eSectionTypeCompactUnwind: "CompactUnwind",
	lldb.eSectionTypeGoSymtab: "GoSymtab",
	lldb.eSectionTypeAbsoluteAddress: "AbsoluteAddress",
	lldb.eSectionTypeDWARFGNUDebugAltLink: "DWARFGNUDebugAltLink",
	lldb.eSectionTypeDWARFDebugTypes: "DWARFDebugTypes",
	lldb.eSectionTypeDWARFDebugNames: "DWARFDebugNames",
	lldb.eSectionTypeOther: "Other",
	lldb.eSectionTypeDWARFDebugLineStr: "DWARFDebugLineStr",
	lldb.eSectionTypeDWARFDebugRngLists: "DWARFDebugRngLists",
	lldb.eSectionTypeDWARFDebugLocLists: "DWARFDebugLocLists",
	lldb.eSectionTypeDWARFDebugAbbrevDwo: "DWARFDebugAbbrevDwo",
	lldb.eSectionTypeDWARFDebugInfoDwo: "DWARFDebugInfoDwo",
	lldb.eSectionTypeDWARFDebugStrDwo: "DWARFDebugStrDwo",
	lldb.eSectionTypeDWARFDebugStrOffsetsDwo: "DWARFDebugStrOffsetsDwo",
	lldb.eSectionTypeDWARFDebugTypesDwo: "DWARFDebugTypesDwo",
	lldb.eSectionTypeDWARFDebugRngListsDwo: "DWARFDebugRngListsDwo",
	lldb.eSectionTypeDWARFDebugLocDwo: "DWARFDebugLocDwo",
	lldb.eSectionTypeDWARFDebugLocListsDwo: "DWARFDebugLocListsDwo",
	lldb.eSectionTypeDWARFDebugTuIndex: "DWARFDebugTuIndex",
}

def calc_section(sec: lldb.SBSection, module_name:str):
    sec_type = sec.GetSectionType()
    sec_type_str  = section_types.get(sec_type, "unknown")
    segment = ""
    if sec_type ==  lldb.eSectionTypeContainer:
        segment = sec.name
    else:
        segment = sec.GetParent().name

    startaddr = sec.GetFileAddress()
    endaddr = startaddr + sec.size

    return (f"{startaddr:x}", f"{endaddr:x}", f"{sec.size:x}", module_name, segment, sec.name, sec_type_str)

if __name__ == '__main__':
    args = get_parser().parse_args()

    headers = ["Start","End","Size","Module","Segment","Section","Sectype"]
    print(",".join(headers))

    # Create a new debugger instance and a target
    debugger = lldb.SBDebugger.Create()
    target = debugger.CreateTarget (args.binary, None, None, args.dependencies, lldb.SBError())

    seclist = []
    if target:
        for module in target.module_iter():
            module_name = os.path.basename(str(module.GetFileSpec()))
            for sec in module.section_iter():
                seclist.append(calc_section(sec, module_name))
                if not args.skip_subsections:
                    for subsec in sec:
                        seclist.append(calc_section(subsec, module_name))
    else:
        print("# Failed to create target.  Check the filetype.", file=sys.stderr)       

    # get max lengths for formatting
    maxlens = [0] * len(headers)
    for sec in seclist:
        for i in range(len(sec)):
            maxlens[i] = max(maxlens[i], len(str(sec[i])))
    
    for sec in seclist:
        print(f"0x{sec[0]:>{maxlens[0]}},0x{sec[1]:>{maxlens[1]}},0x{sec[2]:>{maxlens[2]}},{sec[3]},{sec[4]},{sec[5]},{sec[6]}")
