#!/Library/Developer/CommandLineTools/usr/bin/python3
# NOTE:  must use the python3 in the CommandLineTools directory, not the Homebrew python3
#        because the Homebrew python3 does not have the lldb module

import os

import sys
import argparse
from functools import lru_cache

try:
    # make lldb module available
    sys.path.append('/Library/Developer/CommandLineTools/Library/PrivateFrameworks/LLDB.framework/Versions/A/Resources/Python')
    import lldb
except ImportError:
        print("Failed to import lldb module.  Make sure the path to the lldb module is correct.", file=sys.stderr)
        sys.exit(1)


def validate_binary(path):
    if os.path.exists(path) == False:
        raise argparse.ArgumentTypeError(f"'{path}' does not exist.")
    if not os.path.isfile(path):
        raise argparse.ArgumentTypeError(f"'{path}' is not a file.")
    return path

def get_parser():
    parser = argparse.ArgumentParser(description='List sections in a binary file (executable, shared library, object file, etc.) using lldb')
    parser.add_argument('binary', help='path to the binary to examine.',  type=validate_binary)
    #parser.add_argument('-c', '--csv', action='store_true', help='output in csv format')
    parser.add_argument('-d', '--dependencies', action='store_true', help='also examine dependent binaries')
    parser.add_argument('-k', '--skip-subsections', action='store_true', help='do not list subsections')
    return parser

@lru_cache(None)
def get_section_type_name(section_type):
    for name in dir(lldb):
        if name.startswith("eSectionType") and getattr(lldb, name) == section_type:
            return name[12:]   # remove eSectionType prefix
    return "Unknown"

def calc_section(sec: lldb.SBSection, module_name:str):
    sec_type = sec.GetSectionType()
    sec_type_str  = get_section_type_name(sec_type)
    segment = ""
    if sec_type ==  lldb.eSectionTypeContainer:
        segment = sec.name
    else:
        segment = sec.GetParent().name

    startaddr = sec.GetFileAddress()
    endaddr = startaddr + sec.size

    return (f"{startaddr:x}", f"{endaddr:x}", f"{sec.size}", module_name, segment, sec.name, sec_type_str)

if __name__ == '__main__':
    args = get_parser().parse_args()

    headers = ["Start","End","Size","Module","Segment","Section","Sectype"]
    print(",".join(headers))

    # Create a new debugger instance and a target
    debugger = lldb.SBDebugger.Create()
    target = debugger.CreateTarget (args.binary, None, None, args.dependencies, lldb.SBError())

    seclist = []
    if target:
        for module in target.module_iter():
            module_name = os.path.basename(str(module.GetFileSpec()))
            for sec in module.section_iter():
                seclist.append(calc_section(sec, module_name))
                if not args.skip_subsections:
                    for subsec in sec:
                        seclist.append(calc_section(subsec, module_name))
    else:
        print("# Failed to create target.  Check the filetype.", file=sys.stderr)       

    # get max lengths for formatting
    maxlens = [0] * len(headers)
    for sec in seclist:
        for i in range(len(sec)):
            maxlens[i] = max(maxlens[i], len(str(sec[i])))
    
    for sec in seclist:
        print(f"0x{sec[0]:>{maxlens[0]}},0x{sec[1]:>{maxlens[1]}},{sec[2]:>{maxlens[2]}},{sec[3]},{sec[4]},{sec[5]},{sec[6]}")
